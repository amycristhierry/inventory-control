# Welcome to GitHub Desktop!

在计算期望奖励这类问题时，采用离散方式通常比连续方式更快，下面从原理层面解释离散化为何能提升计算效率。

连续积分计算慢的原因
1. 数值积分的复杂性
在连续积分中，像 scipy.integrate.quad 函数，它会尝试在指定区间内对被积函数进行数值近似计算。该过程往往需要在积分区间内选取大量的采样点，通过不断调整采样点的位置和数量来逼近真实的积分值。这个迭代过程计算量较大，特别是当被积函数比较复杂时，计算时间会显著增加。

2. 函数调用开销
连续积分时，每次计算采样点的函数值都需要进行函数调用，这涉及到参数传递、栈帧创建和销毁等操作，会带来额外的开销。在循环中频繁调用函数，会使得整体的计算效率降低。

离散化计算快的原因
1. 减少计算量
离散化是将连续的分布转化为有限个离散的点及其对应的概率。通过合理选择离散化的点数和范围，可以控制计算量。离散化后，只需要对有限个离散点进行计算，避免了连续积分中大量采样点的计算，从而减少了计算量。

2. 简化计算过程
离散化后的计算过程相对简单，只需要对每个离散点计算对应的奖励值，然后乘以该点的概率并求和即可。这种计算方式避免了复杂的数值积分迭代过程，减少了计算的复杂度。

3. 更适合 JIT 编译
Numba 的 jit 编译在处理简单的循环和数值计算时能发挥很好的优化效果。离散化后的计算逻辑通常是简单的循环结构，更符合 Numba 的优化场景，编译后的代码执行速度会大幅提升。

离散程度与计算速度的关系
一般来说，离散程度越高（即离散点的数量越少），计算速度越快。但离散程度过高可能会导致计算结果的精度下降，因为离散点数量过少可能无法准确反映原始连续分布的特征。因此，在实际应用中需要在计算速度和精度之间进行权衡，选择合适的离散程度。

例如，在之前的代码中，n = 100 表示将正态分布离散为 100 个点，你可以尝试调整 n 的值，观察计算速度和结果精度的变化。如果 n 减小，计算速度会加快，但结果可能不够准确；如果 n 增大，计算结果会更接近真实值，但计算速度会变慢。
